(in-package :bioinformatics)

(defun count-insertion-sort-swaps (data)
  (let ((swaps-count 0))
    (iter (for i from 1 to (1- (length data)))
	  (iter (for k from i downto 1)
		(symbol-macrolet ((data-k (elt data k))
				  (data-k-1 (elt data (1- k))))
		  (while (< data-k data-k-1))
		  (psetf data-k data-k-1
			 data-k-1 data-k)
		  (incf swaps-count))))
    swaps-count))
(define-rosalind-problem :ins insertion-sort-swaps
  "insertion sort"
  (let* ((data (second (read-file-lines input-filename)))
	 (unsorted-data (integer-list data)))
    (count-insertion-sort-swaps (coerce unsorted-data 'vector))))

(defun binary-search (sequence compare)
  (let* ((first 0)
	 (last (length sequence))
	 (count (- last first)))
    (iter (while (> count 0))
	  (let* ((count2 (floor count 2))
		 (mid (+ first count2)))
	    (if (funcall compare (elt sequence mid))
		(progn
		  (setf first (incf mid))
		  (decf count (1+ count2)))
		(setf count count2))))
    first))
(defun position-binary-search (element sorted-array compare)
  (let ((pos (binary-search sorted-array #'(lambda (e) (funcall compare e element)))))
    (when (and (< pos (length sorted-array))
	       (= (elt sorted-array pos) element))
      pos)))
(define-rosalind-problem :bins rosalind-binary-search
  "binary search"
  (let* ((lines (read-file-lines input-filename))
	 (sorted-array (coerce (integer-list (third lines)) 'vector))
	 (elements-to-find (integer-list (fourth lines))))
    (with-output-to-file (output)
      (print-integer-list
	      (iter (for element in elements-to-find)
		    (collect (let ((pos (position-binary-search element sorted-array #'<)))
		      	       (if pos (1+ pos) -1))))))))

(defun make-adjacency-list (lines &optional (graph-type :undirected))
  (let ((adjacency-list (make-hash-table)))
    (iter (for line in (rest lines))
	  (destructuring-bind-integers (head-vertex tail-vertex) line
	    (push tail-vertex (gethash head-vertex adjacency-list))
	    (unless (eq graph-type :directed)
	      (push head-vertex (gethash tail-vertex adjacency-list)))))
    adjacency-list))
(defun make-degree-array (adjacency-list number-vertices)
  (let ((degree-array (make-array number-vertices)))
    (iter (for vertex from 1 to number-vertices)
	  (for vertex-index from 0)
	  (setf (elt degree-array vertex-index) (length (gethash vertex adjacency-list))))
    degree-array))
(define-rosalind-problem :deg degree-array
  "degree array"
  (let* ((lines (read-file-lines input-filename))
	 (adjacency-list (make-adjacency-list lines)))
    (destructuring-bind-integers (number-vertices number-edges) (first lines)
      (declare (ignorable number-edges))
      (print-integer-list
	      (iter (for degree in-vector (make-degree-array adjacency-list number-vertices))
		    (collect degree))))))

(define-rosalind-problem :ddeg double-degree-array
  "double-degree array"
  (let* ((lines (read-file-lines input-filename))
	 (adjacency-list (make-adjacency-list lines)))
    (destructuring-bind-integers (number-vertices number-edges) (first lines)
      (declare (ignorable number-edges))
      (let ((degree-array (make-degree-array adjacency-list number-vertices)))
	(print-integer-list
	 (iter (for vertex from 1 to number-vertices)
	       (collect (iter (for neighbour in (gethash vertex adjacency-list))
			      (summing (elt degree-array (1- neighbour)))))))))))

(defun shortest-distances (number-vertices adjacency-list)
  (let ((reached-vertices (make-hash-table))
	(reachable-vertices (list 1)))
    (iter (while (not (null reachable-vertices)))
	  (for distance from 0)
	  (let (new-vertices)
	    (iter (for vertex in reachable-vertices)
		  (setf (gethash vertex reached-vertices) distance)
		  (iter (for neighbour in (gethash vertex adjacency-list))
			(unless (gethash neighbour reached-vertices)
			  (pushnew neighbour new-vertices))))	    
	    (setf reachable-vertices new-vertices)))
   (iter (for vertex from 1 to number-vertices)
	 (collect (alexandria:if-let ((distance (gethash vertex reached-vertices)))
		    distance
		    -1)))))
(define-rosalind-problem :bfs breadth-first-search
  "breadth first search"
  (let* ((lines (read-file-lines input-filename))
	 (adjacency-list (make-adjacency-list lines :directed)))
    (destructuring-bind-integers (number-vertices number-edges) (first lines)
      (declare (ignore number-edges))
      (print-integer-list (shortest-distances number-vertices adjacency-list)))))

(defun make-random-graph (number-vertices number-edges &optional (stream t))
  (format stream "~a ~a~%" number-vertices number-edges)
  (let (edge-list)
    (iter (until (= number-edges (length edge-list)))
	  (let ((v1 (1+ (random number-vertices)))
		(v2 (1+ (random number-vertices))))
	    (iter (while (= v1 v2))
		  (setf v2 (1+ (random number-vertices))))
	    (pushnew (cons  v1 v2) edge-list
		    :test #'(lambda (e1 e2) (and (= (car e1) (car e2)) (= (cdr e1) (cdr e2)))))))
    (iter (for edge in edge-list)
	  (format stream "~a ~a~%" (car edge) (cdr edge)))))
(defun make-bfs-graph (number-vertices number-edges)
  (with-open-file (stream (make-input-filename :bfs) :direction :output :if-exists :supersede)
    (make-random-graph number-vertices number-edges stream)))

(defun make-bfs-dot ()
  (with-open-file (stream "rosalind_bfs.dot" :direction :output :if-exists :supersede)
    (make-dot-output (make-adjacency-list (rosalind-lines :bfs) :directed) stream)))
(defun make-dot-output (adjacency-list &optional (stream stream))
  (format stream "digraph g {~%")
  (iter (for (vertex neighbours) in-hashtable adjacency-list)
	(iter (for neighbour in neighbours)
	      (format stream "  n~a -> n~a;~%" vertex neighbour)))
  (format stream "}~%"))
